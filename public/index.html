<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>삼국지</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Dokdo&family=Noto+Sans+KR&display=swap" rel="stylesheet">

        <style>
            /* @import url("https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900"); */

            body {
                margin: 0;
                padding: 0;
                font-family: 'Noto Sans KR', sans-serif;
                overflow:hidden;
            }

            canvas {
                display: block;
                margin: 0;
                padding: 0;
                border: none;
                font-family: 'Noto Sans KR', sans-serif;
                image-rendering: pixelated;
            }

            .classChoiceImg {
                image-rendering: pixelated;
                width: 64px;
                height: 64px;
            }

            label {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #vertualkeyboard {
                display: inline-block;
                position:absolute;
                bottom:10%;
                left:50%;
                transform: translate(-50%, 0%);
                opacity:0.4;

                width: 200px;
                height: 130px;


            }
            @media (max-width: 800px) {
                #vertualkeyboard {
                    width: 90%;
                    height: 20%;
                }
            }

            .vertualkey {
                width: 30%;
                height: 45%;
                margin: 1%;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }


            .content {

                position: relative;
                font-family: 'Dokdo', cursive;
                box-sizing: border-box;

                width:100%;
                height:35vw;

                margin-top:20px;


                user-select: none;

            }

            .content h2 {
                color: #fff;
                font-size: 30vw;
                position: absolute;
                margin:0;
                text-align: center;
                width: 100%;

            }

            .content h2:nth-child(1) {
                color: transparent;
                -webkit-text-stroke: 2px #b3d504;
            }

            .content h2:nth-child(2) {
                color: #6b1212;
                animation: animate 4s ease-in-out infinite;
            }

            @keyframes animate {
                0%,
                100% {
                    clip-path: polygon(
                    0% 35%,
                    16% 44%,
                    33% 50%,
                    54% 60%,
                    70% 61%,
                    84% 59%,
                    100% 52%,
                    100% 100%,
                    0% 100%
                    );
                }

                50% {
                    clip-path: polygon(
                    0% 60%,
                    15% 70%,
                    34% 77%,
                    51% 62%,
                    67% 50%,
                    84% 35%,
                    100% 40%,
                    100% 100%,
                    0% 100%
                    );
                }
            }
        </style>

    </head>
    <body>
        <div style="display:inline-block; position:relative;">
            <div id="notification" style="position:absolute; top:0; left:0; color:white;">시작버튼이 보이지 않거나 클릭되지 않으면, 창크기를 조절해보세요</div>
            <div id="startPage" style="width:100%; position:absolute; top:0; bottom:0; left:0; right:0;">
                <div class="content">
                    <h2>삼국지?</h2>
                    <h2>삼국지?</h2>
                </div>


                <div style="display: flex; flex-direction: column; align-items: center; z-index:3;">
                    <div style="color:white; margin-bottom:20px;"> 알파버전: 전투 서버 테스트용</div>

                    <form id="myForm">
                        <div style = "display:flex; gap:5px">
                            <label for="myChoice0"><img class="classChoiceImg" src="https://chimlang.github.io/credit/updates/img/Swordsman.png">
                                <input type="radio" id="myChoice0" name="myChoice" value="0" checked />
                            </label>

                            <label for="myChoice1"><img class="classChoiceImg" src="https://chimlang.github.io/credit/updates/img/Axeman.png">
                                <input type="radio" id="myChoice1" name="myChoice" value="1"  />
                            </label>

                            <label for="myChoice2"><img class="classChoiceImg" src="https://chimlang.github.io/credit/updates/img/Archer.png">
                                <input type="radio" id="myChoice2" name="myChoice" value="2" />
                            </label>

                            <label for="myChoice3"><img class="classChoiceImg" src="https://chimlang.github.io/credit/updates/img/Mounted.png" style="transform: scaleX(-1);">
                                <input type="radio" id="myChoice3" name="myChoice" value="3" />
                            </label>

                        </div>
                        <button type="submit" id="startButton" style="margin:10px auto; display:block;">게임시작</button>
                    </form>

                    <!-- <div> 효과음 배경음 </div> -->
                    <div style="color:white;"> <a href="https://chimlang.github.io/credit/">Credit</a> </div>
                    <div style="color:white;">무덤가(리스폰지역)에 머무르지 마세요.</div>
                    <div style="color:white;">게임시작시 소리가 납니다.</div>
                    <div style="color:white;">조작은 키보드 WASD와 Q E 혹은 J K</div>
                </div>
            </div>

            <div style="position:absolute; top:0px; right:8px">
                <input id="musicOn" type="checkbox" checked onchange="(()=>{musicOn = !musicOn; startSound.pause()})()" style="display: inline-block; vertical-align: middle;">
                <label for="musicOn" style="display: inline-block; vertical-align: middle; color:white;">배경음</label>
            </div>
            <div style="position:absolute; top:15px; right:8px">
                <input id="effectSoundOn" type="checkbox" checked onchange="(()=>{soundEffectOn = !soundEffectOn})()" style="display: inline-block; vertical-align: middle;">
                <label for="effectSoundOn" style="display: inline-block; vertical-align: middle; color:white;">효과음</label>
            </div>
            <!-- <h1>hahah hello world! dfafds</h1> -->
            <div id="playground" hidden>
                <div style="position:absolute; top:45px; right:15px">
                    <input id="seeMyServerPosition" type="checkbox" onchange="(()=>{seeMyServerState = !seeMyServerState})()" style="display: inline-block; vertical-align: middle;">
                    <label for="seeMyServerPosition" style="display: inline-block; vertical-align: middle; color:white;">서버?</label>
                </div>
                <div style="position:absolute; top:30px; right:15px">
                    <input id="seeMap" type="checkbox" checked onchange="(()=>{seeMap = !seeMap})()" style="display: inline-block; vertical-align: middle;">
                    <label for="seeMap" style="display: inline-block; vertical-align: middle; color:white;">지도?</label>
                </div>
                <div id="vertualkeyboard">
                    <button id="q" class="vertualkey" data-key="KeyQ">Q/J</button>
                    <button class="vertualkey" data-key="KeyW">W</button>
                    <button id="e" class="vertualkey" data-key="KeyE">E/K</button>
                    <br />
                    <button class="vertualkey" data-key="KeyA">A</button>
                    <button class="vertualkey" data-key="KeyS">S</button>
                    <button class="vertualkey" data-key="KeyD">D</button>
                </div>
            </div>

            <canvas></canvas>
        </div>

        <button id="ping" hidden>ping</button>

    <script src="/socket.io/socket.io.js"></script>
    <!-- <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.0/gsap.min.js"></script>

    <script src="https://chimlang.github.io/credit/updates/js/names.js"></script>

    <!-- <script src="./battlemap.js"></script> -->
    <!-- <script src="./backgroundMap.js"></script>
    <script src="./objectsMap.js"></script>
    <script src="./villages.js"></script>
    <script src="./obstacles.js"></script> -->

    <script src="https://chimlang.github.io/credit/updates/js/backgroundMap.js"></script>
    <script src="https://chimlang.github.io/credit/updates/js/objectsMap.js"></script>
    <script src="https://chimlang.github.io/credit/updates/js/villages.js"></script>
    <script src="https://chimlang.github.io/credit/updates/js/obstacles.js"></script>
    <script>

        const tileSizeAsset = 16 // pixels Asset
        let tileSize = 64 // pixels to be appeared on screen for each tile

        const mapRows = 100
        const mapCols = 100

        const showRange = 16
        const showRangePixel = (showRange - 1) * tileSize

        const miniMapScale = 2

        const tileAssetCols = 47
        const mapImage = new Image()
        mapImage.src = "https://chimlang.github.io/credit/updates/img/backgroundassetlarge.png"

        let numberOfTeams = 4

        const teamColor = {0: 'cyan', 1:'red', 2:'purple', 3:'green', '-1':'white'}

        class Castle {
            constructor({number, position, owner, name, health = 60}) {
                this.number = number
                this.position = position// new Set(position)
                this.owner = owner
                this.name = name
                this.health = health
            }

            captured(nameNumber) {
                this.owner = frontendPlayers[nameNumber].teamNumber // Team Number
                this.health = 60
            }

            drawHealthBar({cameraX, cameraY}) {
                const castleX = (this.position[0] % mapWidth) * tileSize
                const castleY = Math.floor(this.position[0] / mapWidth) * tileSize
                c.font = "bold 30px Noto Sans KR"
                c.fillStyle = teamColor[this.owner]
                c.fillText(this.name, castleX - cameraX, castleY - cameraY - 15)

                c.fillStyle = "red"
                c.fillRect(castleX - cameraX , castleY - 10 - cameraY, 2 * tileSize * this.health / 60, 8)
                c.fillStyle = "green"
                c.fillRect(castleX - cameraX , castleY - 10 - cameraY, 2 * tileSize * this.health / 60, 8)
            }

        }
        const castles = {
            1: new Castle({number:1, name:"안정", position:[1712,1713,1812,1813], owner: 2}),
            2: new Castle({number:2, name:"업", position:[1188,1189,1288,1289], owner: 0}),
            3: new Castle({number:3, name:"장안", position:[4524,4525,4624,4625], owner: -1}),
            4: new Castle({number:4, name:"낙양", position:[4059,4060,4159,4160], owner: -1}),
            5: new Castle({number:5, name:"한중", position:[8013,8014,8113,8114], owner: 3}),
            6: new Castle({number:6, name:"허창", position:[7586,7587,7686,7687], owner: 1})
        }


    </script>

    <script>
        const walls = obstacles
        const mapWidth = mapRows
        const mapHeight = mapCols

        const checkTheseTiles = []
        // i for y, j for x
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                if (walls.has(i * mapWidth + j)) {
                    checkTheseTiles.push({x: j * tileSize, y: i * tileSize - 2, width: tileSize, height: tileSize - 18}) // -2 for 2 pixel above wall, -18 for head can overlap
                }
            }
        }

        function rectangularCollision({ rectangle1, rectangle2 }) {
            return (
            rectangle1.x + rectangle1.width >= rectangle2.x &&
            rectangle1.x <= rectangle2.x + rectangle2.width &&
            rectangle1.y + rectangle1.height >= rectangle2.y &&
            rectangle1.y <= rectangle2.y + rectangle2.height
            )
        }

        const characterType = {
            0: {type: 'sword', qcool:1000, ecool:2000, offX: 0.15 * tileSize, offY: 0.1 * tileSize, range: tileSize / 4, damage: 6},
            1: {type: 'axe', qcool:1000, ecool:4000, offX: 0.15 * tileSize, offY: 0.1 * tileSize, range: tileSize / 4, damage: 4},
            2: {type: 'bow', qcool:1000, ecool:1700, offX: 0.15 * tileSize, offY: 0.09 * tileSize, range: tileSize / 3, damage: 3},
            3: {type: 'mounted', qcool:1500, ecool:5000, offX: 0.15 * tileSize, offY: 0.09 * tileSize, range: tileSize / 3, damage: 9}
        }

    </script>

   <script>
        const maxmaxhealth = 99
        const basehealth = 30
        const maxlevel = 99
        // f: maxFrames h: holdFrames
        const assetMotion = {}
        assetMotion["0"] = {'idledown':{x:0, y:0, f:2, h:15},
                            'idleup':{x:0, y:16, f:2, h:15},
                            'idleright':{x:0, y:32, f:2, h:15},
                            'idleleft':{x:0, y:48, f:2, h:15},
                            'walkdown':{x:16, y:0, f:4, h:5},
                            'walkup':{x:16, y:16, f:4, h:5},
                            'walkright':{x:16, y:32, f:4, h:5},
                            'walkleft':{x:16, y:48, f:4, h:5},
                            'attack1down':{x:0, y:64, f:4, h:4},
                            'attack1up':{x:0, y:80, f:4, h:4},
                            'attack1right':{x:0, y:96, f:4, h:4},
                            'attack1left':{x:0, y:112, f:4, h:4},
                            'attack2down':{x:0, y:128, f:5, h:4},
                            'attack2up':{x:0, y:144, f:5, h:4},
                            'attack2right':{x:0, y:160, f:5, h:4},
                            'attack2left':{x:0, y:176, f:5, h:4},

                            'offset': {x:0.5, y:0, xend:-1, yend:0},
                            'url': "https://chimlang.github.io/credit/updates/img/SwordsmanRed.png"
                            // 'url': "./image/SwordsmanRed.png"
                            // https://raw.githubusercontent.com/chimlang/realtime/main/public/image/Swordsman.png
                            }

        assetMotion["1"] = {'idledown':{x:0, y:0, f:2, h:15},
                            'idleup':{x:0, y:16, f:2, h:15},
                            'idleright':{x:0, y:32, f:2, h:15},
                            'idleleft':{x:0, y:48, f:2, h:15},
                            'walkdown':{x:16, y:0, f:4, h:5},
                            'walkup':{x:16, y:16, f:4, h:5},
                            'walkright':{x:16, y:32, f:4, h:5},
                            'walkleft':{x:16, y:48, f:4, h:5},
                            'attack2down':{x:0, y:64, f:6, h:3},
                            'attack2up':{x:0, y:64, f:6, h:3},
                            'attack2right':{x:0, y:64, f:6, h:3},
                            'attack2left':{x:0, y:64, f:6, h:3},
                            // 'attack1down':{x:0, y:80, f:4, h:4},
                            // 'attack1up':{x:48, y:80, f:3, h:15},
                            // 'attack1right':{x:32, y:80, f:3, h:5},
                            // 'attack1left':{x:64, y:80, f:2, h:16},
                            'attack1down':{x:0, y:80, f:6, h:3},
                            'attack1up':{x:0, y:80, f:6, h:3},
                            'attack1right':{x:0, y:80, f:6, h:3},
                            'attack1left':{x:0, y:80, f:6, h:3},

                            'offset': {x:0.5, y:0, xend:-1, yend:0},
                            'url': "https://chimlang.github.io/credit/updates/img/AxemanPurple.png"
                            // 'url': "./image/SwordsmanRed.png"
                            }

        assetMotion["2"] = {'idleup':{x:0, y:0, f:2, h:20, width: 64},
                            'idleleft':{x:0, y:64, f:2, h:20, width: 64},
                            'idledown':{x:0, y:64*2, f:2, h:20, width: 64},
                            'idleright':{x:0, y:64*3, f:2, h:20, width: 64},

                            'walkup':{x:64*7, y:64*0, f:9, h:2, width: 64},
                            'walkleft':{x:64*7, y:64*1, f:9, h:2, width: 64},
                            'walkdown':{x:64*7, y:64*2, f:9, h:2, width: 64},
                            'walkright':{x:64*7, y:64*3, f:9, h:2, width: 64},

                            'attack2up':{x:0, y:64*4, f:13, h:1, width: 64},
                            'attack2left':{x:0, y:64*5, f:13, h:1, width: 64},
                            'attack2down':{x:0, y:64*6, f:13, h:1, width: 64},
                            'attack2right':{x:0, y:64*7, f:13, h:1, width: 64},

                            'attack1up':{x:0, y:64*9 + 192 * 0, f:6, h:3, width: 192},
                            'attack1left':{x:0, y:64*9 + 192 * 1, f:6, h:3, width: 192},
                            'attack1down':{x:0, y:64*9 + 192 * 2, f:6, h:3, width: 192},
                            'attack1right':{x:0, y:64*9 + 192 * 3, f:6, h:3, width: 192},

                            'offset': {x:0.5, y:0, xend:-1, yend:0},
                            'url': "https://chimlang.github.io/credit/updates/img/bowElf.png"
                            // 'url': "./image/SwordsmanRed.png"
                            }

        assetMotion["3"] = {'idledown':{x:0, y:0, f:4, h:15, width: 32},
                            'idleright':{x:0, y:32*3, f:4, h:15, width: 32},
                            'idleleft':{x:0, y:32*6, f:4, h:15, width: 32},
                            'idleup':{x:0, y:32*9, f:4, h:15, width: 32},
                            'walkdown':{x:0, y:0, f:4, h:5, width: 32},
                            'walkright':{x:0, y:32*3, f:4, h:5, width: 32},
                            'walkleft':{x:0, y:32*6, f:4, h:5, width: 32},
                            'walkup':{x:0, y:32*9, f:4, h:5, width: 32},
                            'attack1down':{x:0, y:32*2, f:4, h:4, width: 32},
                            'attack1right':{x:0, y:32*5, f:4, h:4, width: 32},
                            'attack1left':{x:0, y:32*8, f:4, h:4, width: 32},
                            'attack1up':{x:0, y:32*11, f:4, h:4, width: 32},
                            'attack2down':{x:0, y:32*1, f:4, h:4, width: 32},
                            'attack2right':{x:0, y:32*4, f:4, h:4, width: 32},
                            'attack2left':{x:0, y:32*7, f:4, h:4, width: 32},
                            'attack2up':{x:0, y:32*10, f:4, h:4, width: 32},

                            'offset': {x:0.5, y:0, xend:-1, yend:0},
                            'url': "https://chimlang.github.io/credit/updates/img/CyanKnight.png"
                            // 'url': "./image/SwordsmanRed.png"
                            }


        function getMotionName(motion, direction) {
            let motionName
            switch (motion) {
                case 1:
                    motionName = 'idle'
                    break
                case 2:
                    motionName = 'walk'
                    break
                case 3:
                    motionName = 'attack1'
                    break
                case 4:
                    motionName = 'attack2'
                    break
            }
            switch (direction) {
                case 1:
                    motionName += 'up'
                    break
                case 2:
                    motionName += 'left'
                    break
                case 3:
                    motionName += 'down'
                    break
                case 4:
                    motionName += 'right'
                    break
            }
            return motionName
        }
        function maxhealth(level, type) {
            // if (type === 0) {
                return Math.floor(basehealth + (maxmaxhealth + 1 - basehealth) * level / (maxlevel + 1))
            // }
        }
        class Player {
            // character level l, type t, state attack or damaged or walking, direction, size, health, maxhealth
            // n: name list number, t: character type
            constructor({ x, y, level, nameNumber, teamNumber, type, scale = 1}) {
                this.x = x
                this.y = y
                this.direction = 3 // 3: down
                this.motion = 1 // 1:idle
                this.level = level
                this.health = maxhealth(level, type)

                this.nameNumber = nameNumber
                this.teamNumber = teamNumber
                this.type = type

                this.scale = scale
                this.framesCurrent = 0
                this.framesElapsed = 0

                this.isDead = false

                this.isPermeable = 7 * 1000 // for 7 seconds this can penetrate, avoiding collision detection on the server


                this.color = teamColor[this.teamNumber] //`hsl(${parseInt(360 * this.teamNumber / numberOfTeams)}, 100%, 50%)`
                this.maxhealth = maxhealth(level, type) // This needs update whenever level changes

                this.image = new Image()
                this.image.src = assetMotion[type].url
                this.motionName = 'idledown'
                this.framesMax = assetMotion[type][this.motionName].f
                this.framesHold = assetMotion[type][this.motionName].h

                this.box = {
                    w: tileSize * (1 + this.level/99) - 2 * characterType[this.type].offX,
                    h: tileSize * (1 + this.level/99) - 2 * characterType[this.type].offY,
                    offX: characterType[this.type].offX,
                    offY: characterType[this.type].offY,
                    range: characterType[this.type].range,
                    damage: characterType[this.type].damage
                }

            }

            draw({cameraX, cameraY}) {
                this.motionName = getMotionName(this.motion, this.direction)

                let assetSize = tileSizeAsset
                let type2multiplier = 1
                let type2off = 0
                if (this.type == 2 || this.type == 3) {
                    assetSize = assetMotion[this.type][this.motionName].width
                    if (this.type == 2 && this.motion == 3) {
                        type2multiplier = 3
                        type2off = -tileSize
                    }
                }

                c.drawImage(
                            this.image,
                            assetMotion[this.type].offset.x + assetMotion[this.type][this.motionName].x + this.framesCurrent * assetSize,
                            assetMotion[this.type].offset.y + assetMotion[this.type][this.motionName].y,
                            assetMotion[this.type].offset.xend + assetSize,
                            assetMotion[this.type].offset.yend + assetSize,
                            this.x + type2off - cameraX,
                            this.y + type2off - cameraY,
                            tileSize * type2multiplier,
                            tileSize * type2multiplier
                        )
            }

            drawOnMiniMap() {
                c.fillStyle = this.color
                c.fillRect(miniMapScale * this.x/tileSize, miniMapScale * this.y/tileSize, miniMapScale, miniMapScale)
            }

            animateFrames() {
                if (this.isDead) return

                this.framesElapsed++

                if (this.framesElapsed % this.framesHold === 0) {

                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++
                    } else {
                        this.framesCurrent = 0
                    }
                }
            }

            switchSprite({motion, direction}) {

                // While attack, don't change sprite till one cycle ends
                if (this.motionName.includes('attack') &&
                    this.framesCurrent < this.framesMax - 1) return

                const newMotionName = getMotionName(motion, direction)

                if (newMotionName === this.motionName) return
                this.motionName = newMotionName
                this.motion = motion
                this.direction = direction
                this.framesMax = assetMotion[this.type][newMotionName].f
                this.framesHold = assetMotion[this.type][this.motionName].h
                this.framesCurrent = 0
            }

            drawHealthBar({cameraX, cameraY}) {
                c.font = "15px Noto Sans KR"
                c.fillStyle = this.color
                c.fillText("lv." + this.level, this.x - cameraX, this.y - 4 - cameraY - 22)

                c.fillStyle = "red"
                if (this.isDead) {
                    c.fillStyle = "black"
                }
                c.fillRect(this.x - cameraX , this.y - 1 - cameraY, 2 * tileSize * this.maxhealth / maxmaxhealth, 4)
                c.fillStyle = "green"
                c.fillRect(this.x - cameraX , this.y - 1 - cameraY, 2 * tileSize * this.health / maxmaxhealth, 4)
            }

            drawName({cameraX, cameraY}) {
                c.font = "20px Noto Sans KR"
                c.fillStyle = this.color
                c.fillText(nameslist[this.nameNumber], this.x - cameraX, this.y - 4 - cameraY)
            }

            levelup() {
                if (this.level < maxlevel) {
                    this.level += 1
                    this.maxhealth = maxhealth(this.level, this.type)
                }
            }
        }
    </script>

    <script>
        // Set canvas
        const canvas = document.querySelector('canvas')
        const c = canvas.getContext('2d')



        canvas.style.backgroundColor = "#282a36"

        window.onload = function() {
            resizeCanvas()
            drawRect()
        }
        window.onresize = function() {
            console.log('resizing')
            resizeCanvas()
            drawRect()
        }

        function resizeCanvas() {
            // const devicePixelRatio = window.devicePixelRatio || 1
            canvas.width = parseInt(window.innerWidth) // * devicePixelRatio) // * 80/100)
            canvas.height = parseInt(window.innerHeight) // * devicePixelRatio) // * 70/100)
            // c.scale(devicePixelRatio, devicePixelRatio)
        }


        function drawRect() {
            let width = c.width * 0.1
            let height = c.height * 0.1
            let xpos = c.width/2 - width/2
            let ypos = c.height/2 - height/2
            c.fillStyle = "#ffffff"
            c.fillRect(xpos, ypos, width, height)
        }
    </script>


    <script>
        let socket
        let sessionid

        function connect() {
            const newSocket = io({
                reconnection: false, // whether to reconnect automatically. I guess this makes browsers go crazy when server is closed
                reconnectionAttempts: Infinity, // number of reconnection attempts before giving up
                reconnectionDelay: 1000, // how long to initially wait before attempting a new reconnection
                reconnectionDelayMax: 5000, // maximum amount of time to wait between reconnections
                randomizationFactor: 0.5, // randomization factor applied to the reconnection delay
                query: { sessionid, selectedClass } // for reconnection. sending previous sessionid
                });

            newSocket.on('connect', () => {
                sessionid = newSocket.id //socket.io.engine.id;
                newSocket.io.opts.query = { sessionid, selectedClass }

                if (socket) {
                    const oldSocket = socket
                    socket = newSocket
                    oldSocket.close()
                }
                else {
                    socket = newSocket
                }

                registerSocketListeners(socket)
            })
        }

        function registerSocketListeners(socket) {

            if (myid) {
                updateNewPlayer()
                updatePlayers()
                listenForCoolReady()
                listenForLevelUp()
                listenDeath()
                listenForCastleCapture()
                updateAttackBoxes()
            }
            else {
                let lineInfrontOfMe
                socket.on('Q=?', (numberOfWatingPlayers) => {
                    lineInfrontOfMe = parseInt(numberOfWatingPlayers)
                    notification.innerText = `${lineInfrontOfMe} 명 앞에 대기중... 새로고침하지 마시고 기다려주세요`
                })
                // socket.on('Q-1', () => {
                //     lineInfrontOfMe -= 1
                //     notification.innerText = `${lineInfrontOfMe} 명 대기중... 새로고침하지 마시고 기다려주세요`
                // })
                listenGameSetUp() //socket.on('gameSetUp'){... updateNewPlayer(); updatePlayers(); animate();}
            }

            socket.on('ipExists', () => {
                alert('Disconnected: Already joined with the same IP')
            })
            socket.on('tooFastEmits', () => {
                alert('Disconnected: Too many emits per time detected. This might be caused from fluctuating ping')
            })
            socket.on('noMoreName', () => {
                alert('Disconnected: No more names left. Max number of joins reached')
            })
            socket.on("pong", () => {
                myping = Math.floor(performance.now() - pingtime)
                // console.log(`${performance.now() - pingtime} ms from sending ping to getting pong`)
            })

        }

    </script>

    <script>
        let frontendAttackBoxes = []
        function updateAttackBoxes() {
            if(!socket.connected) return

            socket.on('A', (a) => {
                frontendAttackBoxes = a
            })
        }
    </script>

    <script>

        const frontendPlayers = {}

        // Connection
        function updateNewPlayer() {
            if (!socket.connected) return
            // Only Old players get and process this socket
            socket.on('updateNewPlayer', (newBackendPlayer) => {
                if (myid === newBackendPlayer.n) return
                if (frontendPlayers[newBackendPlayer.n]) return

                frontendPlayers[newBackendPlayer.n] = new Player({
                                                            x: newBackendPlayer.x,
                                                            y: newBackendPlayer.y,
                                                            level: newBackendPlayer.l,
                                                            teamNumber: newBackendPlayer.c,
                                                            nameNumber: newBackendPlayer.n,
                                                            type: newBackendPlayer.t
                                                        })
            })

            // Only the new player get this socket
            // {bP: backendPlayers, bPS: backendPlayersStatus, bPF: backendPlayersFixed[nameNumber]}
            socket.on('getOldPlayers', (backendPlayers) => {
                for (const nameNumber in backendPlayers.bP) {
                    if (frontendPlayers[nameNumber]) {
                        continue
                    }

                    frontendPlayers[nameNumber] = new Player({
                                                            x: backendPlayers.bP[nameNumber].x,
                                                            y: backendPlayers.bP[nameNumber].y,
                                                            level: backendPlayers.bPS[nameNumber].l,
                                                            teamNumber: backendPlayers.bPF[nameNumber].c,
                                                            nameNumber: backendPlayers.bPF[nameNumber].n,
                                                            type: backendPlayers.bPF[nameNumber].t
                                                        })

                }
            })

            socket.on('getCastleStatus', (castleStatus) => {
                for (let i = 0; i < castleStatus.length; i ++) {
                    castles[i + 1].owner = castleStatus[i]
                }
            })
        }

        function updatePlayers() {
            if (!socket.connected) return
            // Every tick this is sent
            socket.on('P', (backendPlayers) => {

                for (const nameNumber in backendPlayers) {

                    if (!backendPlayers[nameNumber]) {
                        continue
                    }
                    // if this packet arrives before updating new player
                    if (!frontendPlayers[nameNumber]) {
                        continue
                    }

                    const combinedString = backendPlayers[nameNumber];
                    const x = parseInt(combinedString.substring(0, 4));
                    const y = parseInt(combinedString.substring(4, 8));
                    const s = parseInt(combinedString.substring(8, 11));
                    const d = parseInt(combinedString.substring(11, 13));
                    const h = parseInt(combinedString.substring(13, 15));

                    // console.log(typeof nameNumber)
                    frontendPlayers[nameNumber].health = h
                    if (frontendPlayers[nameNumber])  {
                        // note that myid is number and nameNumber is string
                        if (`${myid}` === nameNumber) {
                            frontendPlayers[nameNumber].x = x
                            frontendPlayers[nameNumber].y = y

                            myServerPositionX = x
                            myServerPositionY = y

                            const lastBackendInputIndex = playerInputs.findIndex(input => {
                                return s === input.sequenceNumber
                            })

                            if (lastBackendInputIndex > -1) {
                                playerInputs.splice(0, lastBackendInputIndex + 1)
                            }

                            let sequenceLag
                            if (sequenceNumber < s) {
                                sequenceLag = sequenceMax + sequenceNumber - s
                            }
                            else {
                                sequenceLag = sequenceNumber - s
                            }

                            if (sequenceLag > sequenceMax / 2) {
                                alert("too laggy")
                            }

                            playerInputs.forEach(input => {
                                frontendPlayers[nameNumber].y += input.dy
                                frontendPlayers[nameNumber].x += input.dx
                            })

                            // frontendPlayers[nameNumber].x = Math.round(frontendPlayers[nameNumber].x)
                            // frontendPlayers[nameNumber].y = Math.round(frontendPlayers[nameNumber].y)

                        }
                        else {
                            // frontendPlayers[nameNumber].x = b[nameNumber].x
                            // frontendPlayers[nameNumber].y = b[nameNumber].y

                            let direction = d % 10
                            let motion = Math.floor(d / 10)
                            frontendPlayers[nameNumber].switchSprite({motion, direction})

                            // To use gsap, make sure to uncomment gsap.min.js also
                            // This will make enemy move smooth, but 15ms additional lagging
                            gsap.to(frontendPlayers[nameNumber], {
                                x: x,
                                y: y,
                                duration: frameInterval / 1000,
                                ease: 'linear'
                            })
                        }
                    }
                }

                for (const nameNumber in frontendPlayers) {
                    if (!backendPlayers[nameNumber]) {
                        delete frontendPlayers[nameNumber]
                    }
                }
            })

        }

        function listenForCoolReady() {
            socket.on('Q', () => {
                qready = true
                qButton.style.backgroundColor = 'buttonface'
            })
            socket.on('E', () => {
                eready = true
                eButton.style.backgroundColor = 'buttonface'
            })
        }

        function listenForLevelUp() {
            socket.on('L', (nameNumber) => {
                if (nameNumber == myid) {
                    if (soundEffectOn) {
                        levelupSound.play()
                    }
                }
                frontendPlayers[nameNumber].levelup()
            })
        }

        function listenDeath() {
            socket.on('D', (nameNumber) => {
                frontendPlayers[nameNumber].isDead = true

                if (nameNumber == myid) {
                    if (musicOn) {
                        endSound.play()
                    }
                    setTimeout(() => {
                        location.href = location.href;
                    }, 12 * 1000)
                }
            })
        }

        function listenForCastleCapture() {
            socket.on('C', ({c, h}) => {
                castles[c].health = h
            })
            socket.on('castle', ({where, who}) => {
                castles[where].captured(who)
            })
        }


        const pingButton = document.getElementById("ping")
        pingButton.addEventListener("click", () => {
            socket.emit("ping")
        })


    </script>

    <script>
        let pingtime = 0



    </script>

    <script>
        let animationId
        let lastTimestamp = 0

        let cameraLeft
        let cameraRight
        let cameraAbove
        let cameraBelow

        let seeMyServerState = false
        let seeMap = true
        let myServerPositionX = 0
        let myServerPositionY = 0

        let testCurrentTime = Date.now()

        function animate(timestamp) {
            animationId = requestAnimationFrame(animate)

            if (myid == null || frontendPlayers[myid] == null || frontendPlayers[myid].x == null) {return}

            const deltaTime = timestamp - lastTimestamp;

            const testLastTime = Date.now()
            const testDeltaTime = testLastTime - testCurrentTime
            testCurrentTime = testLastTime

            c.clearRect(0, 0, c.width, c.height)
            c.imageSmoothingEnabled = false;


            c.fillStyle = 'rgba(0,0,0,0.1)'
            c.fillRect(0, 0, canvas.width, canvas.height)

            // const rows = backgroundMap.length
            // const cols = backgroundMap[0].length
            c.fillStyle = 'rgba(100,0,0,0.5)'


            const cameraX = Math.round(frontendPlayers[myid].x - canvas.width / 2 + tileSize / 2)
            const cameraY = Math.round(frontendPlayers[myid].y - canvas.height / 2 + tileSize / 2)

            if (showRange * tileSize < canvas.width / 2) {
                cameraLeft = Math.max(0, Math.floor(frontendPlayers[myid].x / tileSize) - showRange)
                cameraRight = Math.min(mapCols, Math.floor(frontendPlayers[myid].x / tileSize) + showRange + 1)
            }
            else {
                cameraLeft = Math.max(0, Math.floor(frontendPlayers[myid].x / tileSize - canvas.width / (2 * tileSize)) - 1)
                cameraRight = Math.min(mapCols, Math.floor(frontendPlayers[myid].x / tileSize + canvas.width / (2 * tileSize)) + 2)
            }

            if (showRange * tileSize < canvas.height / 2) {
                cameraAbove = Math.max(0, Math.floor(frontendPlayers[myid].y / tileSize) - showRange)
                cameraBelow = Math.min(mapRows, Math.floor(frontendPlayers[myid].y / tileSize) + showRange + 1)
            }
            else {
                cameraAbove = Math.max(0, Math.floor(frontendPlayers[myid].y / tileSize - canvas.height / (2 * tileSize)) - 1)
                cameraBelow = Math.min(mapRows, Math.floor(frontendPlayers[myid].y / tileSize + canvas.height / (2 * tileSize)) + 2)
            }


            for (let row = cameraAbove; row < cameraBelow; row++) {
                for (let col = cameraLeft; col < cameraRight; col++) {
                    // const tileType = backgroundMap[row][col]
                    // if (tileType === 0) {
                    //     // c.fillRect(col * tileSize, row * tileSize, tileSize, tileSize)
                    // }
                    if (backgroundMap[row * mapCols + col]) {
                        c.drawImage(
                            mapImage,
                            ((backgroundMap[row * mapCols + col] - 1) % tileAssetCols) * tileSizeAsset,
                            Math.floor((backgroundMap[row * mapCols + col] - 1) / tileAssetCols) * tileSizeAsset,
                            tileSizeAsset,
                            tileSizeAsset,
                            col * tileSize - cameraX,
                            row * tileSize - cameraY,
                            tileSize,
                            tileSize
                        )
                    }
                    if (objectsMap[row * mapCols + col]) {
                        c.drawImage(
                            mapImage,
                            ((objectsMap[row * mapCols + col] - 1) % tileAssetCols) * tileSizeAsset,
                            Math.floor((objectsMap[row * mapCols + col] - 1) / tileAssetCols) * tileSizeAsset,
                            tileSizeAsset,
                            tileSizeAsset,
                            col * tileSize - cameraX,
                            row * tileSize - cameraY,
                            tileSize,
                            tileSize
                        )
                    }

                    for (let i = 1; i <= 6; i++) {
                        if (villages[i][row * mapCols + col]) {
                            let villageColor
                            switch (castles[i].owner) {
                                case 0:
                                    villageColor = 0
                                    break
                                case 1:
                                    villageColor = 6
                                    break
                                case 2:
                                    villageColor = 6 * 2
                                    break
                                case 3:
                                    villageColor = 6 * 3
                                    break
                                case "empty":
                                    continue
                            }
                            c.drawImage(
                                mapImage,
                                ((villages[i][row * mapCols + col] - 1) % tileAssetCols + villageColor) * tileSizeAsset,
                                Math.floor((villages[i][row * mapCols + col] - 1) / tileAssetCols) * tileSizeAsset,
                                tileSizeAsset,
                                tileSizeAsset,
                                col * tileSize - cameraX,
                                row * tileSize - cameraY,
                                tileSize,
                                tileSize
                            )
                        }
                    }

                }
            }

            c.fillStyle = 'rgba(255,0,0,1)'
            c.save()
            c.globalCompositeOperation = "destination-in"

            c.fillRect(canvas.width/2 - showRangePixel, canvas.height/2 - showRangePixel, 2 * showRangePixel, 2 * showRangePixel)
            c.restore()

            for (const attackBox of frontendAttackBoxes) {
                if (attackBox.r === 1) {
                    c.fillStyle = 'rgba(255,0,0,1)'
                    c.fillRect(attackBox.x - cameraX, attackBox.y - cameraY, 10, 10)
                }
                else if (attackBox.r === 2) {
                    c.fillStyle = 'rgba(50,50,50,0.8)'
                    c.fillRect(attackBox.x - cameraX, attackBox.y - cameraY, 10, 10)
                    //c.fillRect(Math.floor(attackBox.x - cameraX - tileSize), Math.floor(attackBox.y - cameraY - tileSize), 2 * tileSize, 2 * tileSize)
                }
            }

            if (seeMap) {
                c.fillStyle = 'rgba(50,50,50,0.5)'
                c.fillRect(0, 0, 200, 200)

                for (const castleNumber in castles) {
                    c.fillStyle = 'rgba(255,255,255,1)'
                    c.fillRect(miniMapScale * (castles[castleNumber].position[0] % mapWidth - 1), miniMapScale * (Math.floor(castles[castleNumber].position[0] / mapWidth) - 1), 2 * miniMapScale + 1, 2 * miniMapScale + 1)
                    if (castles[castleNumber].owner !== -1) {
                        c.fillStyle = teamColor[castles[castleNumber].owner]
                        c.fillRect(miniMapScale * (castles[castleNumber].position[0] % mapWidth - 1) + 1 , miniMapScale * (Math.floor(castles[castleNumber].position[0] / mapWidth) - 1) + 1 , miniMapScale + 1, miniMapScale + 1)

                    }

                    castles[castleNumber].drawHealthBar({cameraX, cameraY})
                }


                c.fillStyle = 'rgba(255,255,255,0.3)'
                c.fillRect(200, 0, 100, 200)

                const showranker = 10
                let counter = 1

                const ranking = Object.keys(frontendPlayers).sort((a, b) => {return -frontendPlayers[a].level + frontendPlayers[b].level})
                const myranking = ranking.indexOf(`${myid}`) + 1

                for (const nameNumber of ranking) {
                    c.font = "13px Noto Sans KR"
                    c.fillStyle = frontendPlayers[nameNumber].color
                    c.fillText(frontendPlayers[nameNumber].level + ' ' + nameslist[nameNumber], 200, 15 * counter)
                    counter += 1
                    if (counter > showranker) {
                        break
                    }
                }
                c.font = "15px Noto Sans KR"
                c.fillStyle = 'black'
                c.fillText( '내 순위: ' + myranking, 200, 17 * counter)
                counter += 1
                c.fillText( 'Ping: ' + myping + " ms", 200, 17 * counter)
            }


            for (const nameNumber in frontendPlayers) {

                const frontendPlayer = frontendPlayers[nameNumber]

                let shouldrestore = false

                if (frontendPlayer.isPermeable > 0) {
                    frontendPlayer.isPermeable -= testDeltaTime
                    c.save()
                    c.globalAlpha = 0.4
                    shouldrestore = true
                }

                frontendPlayer.draw({cameraX, cameraY})
                if (seeMap) {
                    frontendPlayer.drawOnMiniMap()
                }
                if (deltaTime > frameInterval) {
                    frontendPlayer.animateFrames()
                }
                frontendPlayer.drawHealthBar({cameraX, cameraY})
                frontendPlayer.drawName({cameraX, cameraY})

                if (shouldrestore) {
                    c.restore()
                }
                // console.log(frontendPlayer.direction)
            }

            if (frontendPlayers[myid].isPermeable > 0) {
                c.fillStyle = 'rgba(0,0,0,0.4)'
                c.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 245, 300, 150)
                c.font = "bold 30px Noto Sans KR"
                c.fillStyle = 'rgba(255,210,50,1)'
                c.fillText('게임 시작 후 7초 동안', canvas.width / 2 - 140, canvas.height / 2 - 200)
                c.fillText('이동하여 다른 사람과', canvas.width / 2 - 140, canvas.height / 2 - 160)
                c.fillText('겹치지 않게 해주세요', canvas.width / 2 - 140, canvas.height / 2 - 120)
            }

            if (frontendPlayers[myid].isDead) {
                c.fillStyle = 'rgba(0,0,0,0.4)'
                c.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 150, 300, 300)
                c.font = "bold 40px Noto Sans KR"
                c.fillStyle = 'rgba(255,210,50,1)'
                c.fillText('\"좌절감이', canvas.width / 2 - 140, canvas.height / 2 - 100)
                c.fillText(' 사나이를', canvas.width / 2 - 140, canvas.height / 2 - 50)
                c.fillText(' 키우는 것이다\"', canvas.width / 2 - 140, canvas.height / 2)
                c.font = "30px Noto Sans KR"
                c.fillText('10초 후', canvas.width / 2 - 140, canvas.height / 2 + 70)
                c.fillText('새로고침됩니다', canvas.width / 2 - 140, canvas.height / 2 + 120)
            }

            if (seeMyServerState) {
                c.fillStyle = 'rgba(0,255,0,0.2)'
                c.fillRect(myServerPositionX - cameraX, myServerPositionY - cameraY, tileSize, tileSize)
            }


            if (deltaTime > frameInterval) {
                playersimul()
                lastTimestamp = timestamp;
            }
        }

    </script>

    <script>
        // default 15ms but, after "gameSetUp" socket on, this changes
        let frameInterval = 30
        let speed
        let myid

        let ranking = []
        let myranking = "?"
        let myping = "?"


        function listenGameSetUp() {
            socket.on("gameSetUp", (gameSetUp) => {
                frameInterval = parseInt(gameSetUp['frameInterval'])
                speed = gameSetUp['speed']
                numberOfTeams = gameSetUp['numberOfTeams']
                myid = gameSetUp['yourid']
                //console.log(typeof myid)
                tileSize = gameSetUp['tileSize']

                notification.hidden = true

                updateNewPlayer()
                updatePlayers()
                listenForCoolReady()
                listenForLevelUp()
                listenDeath()
                listenForCastleCapture()
                updateAttackBoxes()
                testCurrentTime = Date.now()
                animate()


            })
        }

    </script>


    <script>

        function startGame() { //type) {
            connect()
            // socket.emit('t', type)

            setInterval(() => {
                connect()
            }, 4 * 60 * 1000)

            setInterval(() => {
                pingtime = performance.now()
                socket.emit("ping")
            }, 20 * 1000)

        }



    </script>



    <script>

        const keys = {
            w: {
                pressed: false
            },
            a: {
                pressed: false
            },
            s: {
                pressed: false
            },
            d: {
                pressed: false
            },
            q: {
                pressed: false
            },
            e : {
                pressed: false
            }
        }
        // const keysToEmit = {w: keys.w.pressed, a: keys.a.pressed, s: keys.s.pressed, d: keys.d.pressed}
        // 0, 1 takes less size than flase, true in stringified socket data
        const keysToEmit = {w:0, a:0, s:0, d:0, q:0, e:0}
        const movementInput = {dx: 0, dy: 0}

        const playerInputs = []
        let sequenceNumber = 0
        const sequenceMax = 1000 // sequenceNumber: 0~999

        let qready = true
        let eready = true

        function playersimul() {
            if (!socket.connected) return
            if (frontendPlayers[myid].isDead) return
            // const myFrontendPlayer = frontendPlayers[myid]

            let motion = frontendPlayers[myid].motion
            let direction = frontendPlayers[myid].direction


            if (keys.w.pressed) {
                // sequenceNumber: sequenceNumber is the same as sequenceNumber
                let blocked = false

                // let playerBox = {x: frontendPlayers[myid].x +frontendPlayers[myid].box.offX, y: frontendPlayers[myid].y - speed + frontendPlayers[myid].box.offY, width: frontendPlayers[myid].box.w, height: frontendPlayers[myid].box.h}
                // for (const tileRect of checkTheseTiles) {
                //     if (rectangularCollision({ rectangle1: playerBox, rectangle2:tileRect})) {
                //         blocked = true
                //         break
                //     }
                // }
                // if (!blocked) {
                //     for (const otherName in frontendPlayers) {
                //         if (parseInt(otherName) !== myid && rectangularCollision({rectangle1: playerBox, rectangle2: {x: frontendPlayers[otherName].x + frontendPlayers[otherName].box.offX, y: frontendPlayers[otherName].y + frontendPlayers[otherName].box.offY, width: frontendPlayers[otherName].box.w, height: frontendPlayers[otherName].box.h} })) {
                //             blocked = true
                //             break
                //         }
                //     }
                // }

                if (!blocked) {
                    movementInput.dy -= speed
                    frontendPlayers[myid].y -= speed
                    motion = 2

                    keysToEmit.w = 1
                }
                direction = 1
            }
            if (keys.a.pressed) {
                let blocked = false

                // let playerBox = {x: frontendPlayers[myid].x - speed +frontendPlayers[myid].box.offX, y: frontendPlayers[myid].y + frontendPlayers[myid].box.offY, width: frontendPlayers[myid].box.w, height: frontendPlayers[myid].box.h}
                // for (const tileRect of checkTheseTiles) {
                //     if (rectangularCollision({ rectangle1: playerBox, rectangle2:tileRect})) {
                //         blocked = true
                //         break
                //     }
                // }
                // if (!blocked) {
                //     for (const otherName in frontendPlayers) {
                //         if (parseInt(otherName) !== myid && rectangularCollision({rectangle1: playerBox, rectangle2: {x: frontendPlayers[otherName].x + frontendPlayers[otherName].box.offX, y: frontendPlayers[otherName].y + frontendPlayers[otherName].box.offY, width: frontendPlayers[otherName].box.w, height: frontendPlayers[otherName].box.h} })) {
                //             blocked = true
                //             break
                //         }
                //     }
                // }

                if (!blocked) {
                    movementInput.dx -= speed
                    frontendPlayers[myid].x -= speed
                    motion = 2

                    keysToEmit.a = 1
                }
                direction = 2
            }
            if (keys.s.pressed) {
                let blocked = false

                // let playerBox = {x: frontendPlayers[myid].x +frontendPlayers[myid].box.offX, y: frontendPlayers[myid].y + speed + frontendPlayers[myid].box.offY, width: frontendPlayers[myid].box.w, height: frontendPlayers[myid].box.h}
                // for (const tileRect of checkTheseTiles) {
                //     if (rectangularCollision({ rectangle1: playerBox, rectangle2:tileRect})) {
                //         blocked = true
                //         break
                //     }
                // }
                // if (!blocked) {
                //     for (const otherName in frontendPlayers) {
                //         if (parseInt(otherName) !== myid && rectangularCollision({rectangle1: playerBox, rectangle2: {x: frontendPlayers[otherName].x + frontendPlayers[otherName].box.offX, y: frontendPlayers[otherName].y + frontendPlayers[otherName].box.offY, width: frontendPlayers[otherName].box.w, height: frontendPlayers[otherName].box.h} })) {
                //             blocked = true
                //             break
                //         }
                //     }
                // }

                if (!blocked) {
                    movementInput.dy += speed
                    frontendPlayers[myid].y += speed
                    motion = 2

                    keysToEmit.s = 1
                }
                direction = 3
            }
            if (keys.d.pressed) {
                let blocked = false

                // let playerBox = {x: frontendPlayers[myid].x + speed +frontendPlayers[myid].box.offX, y: frontendPlayers[myid].y + frontendPlayers[myid].box.offY, width: frontendPlayers[myid].box.w, height: frontendPlayers[myid].box.h}
                // for (const tileRect of checkTheseTiles) {
                //     if (rectangularCollision({ rectangle1: playerBox, rectangle2:tileRect})) {
                //         blocked = true
                //         break
                //     }
                // }
                // if (!blocked) {
                //     for (const otherName in frontendPlayers) {
                //         if (parseInt(otherName) !== myid && rectangularCollision({rectangle1: playerBox, rectangle2: {x: frontendPlayers[otherName].x + frontendPlayers[otherName].box.offX, y: frontendPlayers[otherName].y + frontendPlayers[otherName].box.offY, width: frontendPlayers[otherName].box.w, height: frontendPlayers[otherName].box.h} })) {
                //             blocked = true
                //             break
                //         }
                //     }
                // }

                if (!blocked) {
                    movementInput.dx += speed
                    frontendPlayers[myid].x += speed
                    motion = 2

                    keysToEmit.d = 1
                }
                direction = 4
            }


            if (keys.q.pressed) {
                motion = 3
                keysToEmit.q = 1
                if (!qready) {
                    motion = 1
                    // keysToEmit.q = 0
                }
                else {
                    qButton.style.backgroundColor = 'red'
                    if (soundEffectOn) {
                        attackSound.play()
                    }

                }
            }
            if (keys.e.pressed) {
                motion = 4
                keysToEmit.e = 1
                if (!eready) {
                    motion = 1
                    // keysToEmit.e = 0
                }
                else {
                    eButton.style.backgroundColor = 'red'
                    if (soundEffectOn) {
                        switch (frontendPlayers[myid].type) {
                            case 0:
                                shieldSound.play()
                                break
                            case 1:
                                thrawSound.play()
                                break
                            case 2:
                                thrawSound.play()
                                break
                            case 3:
                                speedSound.play()
                                break
                        }
                    }

                }
            }




            if (motion !== frontendPlayers[myid].motion || direction !== frontendPlayers[myid].direction) {
                frontendPlayers[myid].switchSprite({motion, direction})
            }


            if (keysToEmit.w || keysToEmit.a || keysToEmit.s || keysToEmit.d || keysToEmit.q || keysToEmit.e) {
                sequenceNumber++
                sequenceNumber %= sequenceMax

                playerInputs.push({sequenceNumber, dx: movementInput.dx, dy: movementInput.dy})

                const decimalValue = parseInt(`${keysToEmit.w}${keysToEmit.a}${keysToEmit.s}${keysToEmit.d}${keysToEmit.q}${keysToEmit.e}`,2)
                const k = decimalValue.toString(32) // 2~36. 64 is impossible. I chose 32

                const s = sequenceNumber
                const d = direction + 10 * motion

                if (30 < d && d < 40) {
                    qready = false
                }
                if (40 < d && d < 50) {
                    eready = false
                }
                socket.emit('k', {k, s, d})

                movementInput.dx = 0
                movementInput.dy = 0
                keysToEmit.w = 0
                keysToEmit.a = 0
                keysToEmit.s = 0
                keysToEmit.d = 0
                keysToEmit.q = 0
                keysToEmit.e = 0
            }
            else {
                // Back to idle motion
                // ??? have to stop spamming this. attack (or move) then release keyboard. there is time gap between motino to be assigned as 1
                if (motion !== 1) {
                    frontendPlayers[myid].switchSprite({motion:1, direction})
                    socket.emit('i')
                }
            }

        }

        let isAttacking = false

        window.addEventListener('keydown', (e) => {
            if (!frontendPlayers[myid]) return
            // if (!socket.connected) {
            //     //alert('Disconnected: this window has been inactive for long time. refresh the page')
            //     return
            // }

            switch(e.code) {
                case 'KeyW':
                    keys.w.pressed = true
                    break
                case 'KeyA':
                    keys.a.pressed = true
                    break
                case 'KeyS':
                    keys.s.pressed = true
                    break
                case 'KeyD':
                    keys.d.pressed = true
                    break
                case 'KeyQ':
                    keys.q.pressed = true
                    isAttacking = true
                    break
                case 'KeyE':
                    keys.e.pressed = true
                    isAttacking = true
                    break
                case 'KeyJ':
                    keys.q.pressed = true
                    isAttacking = true
                    break
                case 'KeyK':
                    keys.e.pressed = true
                    isAttacking = true
                    break
            }
        })

        window.addEventListener('keyup', (e) => {
            if (!frontendPlayers[myid]) return

            switch(e.code) {
                case 'KeyW':
                    keys.w.pressed = false
                    break
                case 'KeyA':
                    keys.a.pressed = false
                    break
                case 'KeyS':
                    keys.s.pressed = false
                    break
                case 'KeyD':
                    keys.d.pressed = false
                    break
                case 'KeyQ':
                    keys.q.pressed = false
                    break
                case 'KeyE':
                    keys.e.pressed = false
                    break
                case 'KeyJ':
                    keys.q.pressed = false
                    break
                case 'KeyK':
                    keys.e.pressed = false
                    break
            }
        })
    </script>

    <script>
        let musicOn = true
        let soundEffectOn = true

        const confirmSound = new Audio("https://chimlang.github.io/credit/updates/sound/013_Confirm_03.mp3");
        const startSound = new Audio("https://chimlang.github.io/credit/updates/sound/17_SNES-Castle01.mp3");
        const endSound = new Audio("https://chimlang.github.io/credit/updates/sound/07_SNES-Event11.mp3");
        const levelupSound = new Audio("https://chimlang.github.io/credit/updates/sound/02_Heal_02.mp3");
        const attackSound = new Audio("https://chimlang.github.io/credit/updates/sound/35_Miss_Evade.mp3");
        const thrawSound = new Audio("https://chimlang.github.io/credit/updates/sound/77_flesh.mp3");
        const speedSound = new Audio("https://chimlang.github.io/credit/updates/sound/48_Speed_Up_02.mp3");
        const shieldSound = new Audio("https://chimlang.github.io/credit/updates/sound/15_Impact_flesh.mp3");
    </script>


    <script>
        const startPage = document.querySelector("#startPage")
        const vertualkeyboard = document.querySelector("#playground")
        const notification = document.querySelector("#notification")

        const myForm = document.getElementById('myForm')
        let selectedClass

        myForm.addEventListener('submit', (event) => {
            event.preventDefault()

            if (soundEffectOn) {
                confirmSound.play()
            }

            if (musicOn) {
                startSound.play()
            }


            const formData = new FormData(myForm)
            selectedClass = formData.get('myChoice')

            startGame(selectedClass)
            startPage.hidden = true
            vertualkeyboard.hidden = false
            // notification.hidden = true
        })
    </script>


    <script>


        const vertualkeys = document.querySelectorAll(".vertualkey");
        vertualkeys.forEach((vertualkey) => {
            vertualkey.addEventListener("mousedown", () => {
                const keyDownEvent = new KeyboardEvent("keydown", {
                    key: vertualkey.textContent,
                    code: vertualkey.getAttribute("data-key"),
                });
                window.dispatchEvent(keyDownEvent);
            });
            vertualkey.addEventListener("mouseup", () => {
                const keyUpEvent = new KeyboardEvent("keyup", {
                    key: vertualkey.textContent,
                    code: vertualkey.getAttribute("data-key"),
                });
                window.dispatchEvent(keyUpEvent);
            });
            vertualkey.addEventListener("touchstart", () => {
                const keyDownEvent = new KeyboardEvent("keydown", {
                    key: vertualkey.textContent,
                    code: vertualkey.getAttribute("data-key"),
                });
                window.dispatchEvent(keyDownEvent);
            });
            vertualkey.addEventListener("touchend", () => {
                const keyUpEvent = new KeyboardEvent("keyup", {
                    key: vertualkey.textContent,
                    code: vertualkey.getAttribute("data-key"),
                });
                window.dispatchEvent(keyUpEvent);
            });
        });
    </script>

    <script>
        const qButton = document.querySelector("#q")
        const eButton = document.querySelector("#e")
    </script>

    </body>
</html>
